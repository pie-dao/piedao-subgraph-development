// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class GlobalStat extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save GlobalStat entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save GlobalStat entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("GlobalStat", id.toString(), this);
  }

  static load(id: string): GlobalStat | null {
    return store.get("GlobalStat", id) as GlobalStat | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get depositedLocksCounter(): BigInt {
    let value = this.get("depositedLocksCounter");
    return value.toBigInt();
  }

  set depositedLocksCounter(value: BigInt) {
    this.set("depositedLocksCounter", Value.fromBigInt(value));
  }

  get depositedLocksValue(): BigInt {
    let value = this.get("depositedLocksValue");
    return value.toBigInt();
  }

  set depositedLocksValue(value: BigInt) {
    this.set("depositedLocksValue", Value.fromBigInt(value));
  }

  get withdrawnLocksCounter(): BigInt {
    let value = this.get("withdrawnLocksCounter");
    return value.toBigInt();
  }

  set withdrawnLocksCounter(value: BigInt) {
    this.set("withdrawnLocksCounter", Value.fromBigInt(value));
  }

  get withdrawnLocksValue(): BigInt {
    let value = this.get("withdrawnLocksValue");
    return value.toBigInt();
  }

  set withdrawnLocksValue(value: BigInt) {
    this.set("withdrawnLocksValue", Value.fromBigInt(value));
  }

  get ejectedLocksCounter(): BigInt {
    let value = this.get("ejectedLocksCounter");
    return value.toBigInt();
  }

  set ejectedLocksCounter(value: BigInt) {
    this.set("ejectedLocksCounter", Value.fromBigInt(value));
  }

  get ejectedLocksValue(): BigInt {
    let value = this.get("ejectedLocksValue");
    return value.toBigInt();
  }

  set ejectedLocksValue(value: BigInt) {
    this.set("ejectedLocksValue", Value.fromBigInt(value));
  }

  get boostedLocksCounter(): BigInt {
    let value = this.get("boostedLocksCounter");
    return value.toBigInt();
  }

  set boostedLocksCounter(value: BigInt) {
    this.set("boostedLocksCounter", Value.fromBigInt(value));
  }

  get boostedLocksValue(): BigInt {
    let value = this.get("boostedLocksValue");
    return value.toBigInt();
  }

  set boostedLocksValue(value: BigInt) {
    this.set("boostedLocksValue", Value.fromBigInt(value));
  }

  get averageTimeLock(): BigInt {
    let value = this.get("averageTimeLock");
    return value.toBigInt();
  }

  set averageTimeLock(value: BigInt) {
    this.set("averageTimeLock", Value.fromBigInt(value));
  }

  get totalDoughStaked(): BigInt {
    let value = this.get("totalDoughStaked");
    return value.toBigInt();
  }

  set totalDoughStaked(value: BigInt) {
    this.set("totalDoughStaked", Value.fromBigInt(value));
  }

  get veTokenTotalSupply(): BigInt {
    let value = this.get("veTokenTotalSupply");
    return value.toBigInt();
  }

  set veTokenTotalSupply(value: BigInt) {
    this.set("veTokenTotalSupply", Value.fromBigInt(value));
  }

  get stakersCounter(): BigInt {
    let value = this.get("stakersCounter");
    return value.toBigInt();
  }

  set stakersCounter(value: BigInt) {
    this.set("stakersCounter", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Staker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Staker entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Staker entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Staker", id.toString(), this);
  }

  static load(id: string): Staker | null {
    return store.get("Staker", id) as Staker | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get accountLocks(): Array<string> {
    let value = this.get("accountLocks");
    return value.toStringArray();
  }

  set accountLocks(value: Array<string>) {
    this.set("accountLocks", Value.fromStringArray(value));
  }

  get accountRewards(): Array<string> {
    let value = this.get("accountRewards");
    return value.toStringArray();
  }

  set accountRewards(value: Array<string>) {
    this.set("accountRewards", Value.fromStringArray(value));
  }

  get accountVeTokenBalance(): BigInt {
    let value = this.get("accountVeTokenBalance");
    return value.toBigInt();
  }

  set accountVeTokenBalance(value: BigInt) {
    this.set("accountVeTokenBalance", Value.fromBigInt(value));
  }

  get accountWithdrawableRewards(): BigInt {
    let value = this.get("accountWithdrawableRewards");
    return value.toBigInt();
  }

  set accountWithdrawableRewards(value: BigInt) {
    this.set("accountWithdrawableRewards", Value.fromBigInt(value));
  }

  get accountWithdrawnRewards(): BigInt {
    let value = this.get("accountWithdrawnRewards");
    return value.toBigInt();
  }

  set accountWithdrawnRewards(value: BigInt) {
    this.set("accountWithdrawnRewards", Value.fromBigInt(value));
  }
}

export class StakersTracker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save StakersTracker entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakersTracker entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("StakersTracker", id.toString(), this);
  }

  static load(id: string): StakersTracker | null {
    return store.get("StakersTracker", id) as StakersTracker | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get stakers(): Array<string> {
    let value = this.get("stakers");
    return value.toStringArray();
  }

  set stakers(value: Array<string>) {
    this.set("stakers", Value.fromStringArray(value));
  }
}

export class LocksTracker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save LocksTracker entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save LocksTracker entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("LocksTracker", id.toString(), this);
  }

  static load(id: string): LocksTracker | null {
    return store.get("LocksTracker", id) as LocksTracker | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get locks(): Array<string> {
    let value = this.get("locks");
    return value.toStringArray();
  }

  set locks(value: Array<string>) {
    this.set("locks", Value.fromStringArray(value));
  }
}

export class GlobalStatsTracker extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save GlobalStatsTracker entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save GlobalStatsTracker entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("GlobalStatsTracker", id.toString(), this);
  }

  static load(id: string): GlobalStatsTracker | null {
    return store.get("GlobalStatsTracker", id) as GlobalStatsTracker | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get latest(): string {
    let value = this.get("latest");
    return value.toString();
  }

  set latest(value: string) {
    this.set("latest", Value.fromString(value));
  }

  get globalStats(): Array<string> {
    let value = this.get("globalStats");
    return value.toStringArray();
  }

  set globalStats(value: Array<string>) {
    this.set("globalStats", Value.fromStringArray(value));
  }
}

export class Reward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Reward entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Reward entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Reward", id.toString(), this);
  }

  static load(id: string): Reward | null {
    return store.get("Reward", id) as Reward | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get staker(): string {
    let value = this.get("staker");
    return value.toString();
  }

  set staker(value: string) {
    this.set("staker", Value.fromString(value));
  }

  get rewardToken(): Bytes {
    let value = this.get("rewardToken");
    return value.toBytes();
  }

  set rewardToken(value: Bytes) {
    this.set("rewardToken", Value.fromBytes(value));
  }

  get windowIndex(): BigInt {
    let value = this.get("windowIndex");
    return value.toBigInt();
  }

  set windowIndex(value: BigInt) {
    this.set("windowIndex", Value.fromBigInt(value));
  }

  get accountIndex(): BigInt {
    let value = this.get("accountIndex");
    return value.toBigInt();
  }

  set accountIndex(value: BigInt) {
    this.set("accountIndex", Value.fromBigInt(value));
  }

  get type(): string {
    let value = this.get("type");
    return value.toString();
  }

  set type(value: string) {
    this.set("type", Value.fromString(value));
  }
}

export class RewardDistribution extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RewardDistribution entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RewardDistribution entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RewardDistribution", id.toString(), this);
  }

  static load(id: string): RewardDistribution | null {
    return store.get("RewardDistribution", id) as RewardDistribution | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get windowIndex(): BigInt {
    let value = this.get("windowIndex");
    return value.toBigInt();
  }

  set windowIndex(value: BigInt) {
    this.set("windowIndex", Value.fromBigInt(value));
  }

  get rewardsDeposited(): BigInt {
    let value = this.get("rewardsDeposited");
    return value.toBigInt();
  }

  set rewardsDeposited(value: BigInt) {
    this.set("rewardsDeposited", Value.fromBigInt(value));
  }

  get rewardToken(): Bytes {
    let value = this.get("rewardToken");
    return value.toBytes();
  }

  set rewardToken(value: Bytes) {
    this.set("rewardToken", Value.fromBytes(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class Lock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Lock entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Lock entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Lock", id.toString(), this);
  }

  static load(id: string): Lock | null {
    return store.get("Lock", id) as Lock | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lockId(): BigInt {
    let value = this.get("lockId");
    return value.toBigInt();
  }

  set lockId(value: BigInt) {
    this.set("lockId", Value.fromBigInt(value));
  }

  get lockDuration(): BigInt {
    let value = this.get("lockDuration");
    return value.toBigInt();
  }

  set lockDuration(value: BigInt) {
    this.set("lockDuration", Value.fromBigInt(value));
  }

  get lockedAt(): BigInt {
    let value = this.get("lockedAt");
    return value.toBigInt();
  }

  set lockedAt(value: BigInt) {
    this.set("lockedAt", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get staker(): string {
    let value = this.get("staker");
    return value.toString();
  }

  set staker(value: string) {
    this.set("staker", Value.fromString(value));
  }

  get withdrawn(): boolean {
    let value = this.get("withdrawn");
    return value.toBoolean();
  }

  set withdrawn(value: boolean) {
    this.set("withdrawn", Value.fromBoolean(value));
  }

  get ejected(): boolean {
    let value = this.get("ejected");
    return value.toBoolean();
  }

  set ejected(value: boolean) {
    this.set("ejected", Value.fromBoolean(value));
  }

  get boosted(): boolean {
    let value = this.get("boosted");
    return value.toBoolean();
  }

  set boosted(value: boolean) {
    this.set("boosted", Value.fromBoolean(value));
  }

  get boostedPointer(): string {
    let value = this.get("boostedPointer");
    return value.toString();
  }

  set boostedPointer(value: string) {
    this.set("boostedPointer", Value.fromString(value));
  }
}

export class Delegate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Delegate entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Delegate entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Delegate", id.toString(), this);
  }

  static load(id: string): Delegate | null {
    return store.get("Delegate", id) as Delegate | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    return value.toBytes();
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    return value.toBytes();
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }
}
